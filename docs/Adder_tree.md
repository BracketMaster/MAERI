## Adder Tree

The adder tree builder serves as a structural reference to the actual implementation on FPGA.

### Node

A tree node consist of the following fields:
```python
class node:
    def __init__(self, id):
        self.id = id         # to distinguish itself
        self.lhs = None      # left hand side (child)
        self.rhs = None      # right hand side (child)
        self.parent = None   # parent
```

### Tree structure

The file ```tree.py``` builds a balanced binary tree out of one parameter ```depth```. For example, call ```BalancedBinaryTree(4)``` will yield a tree consisting of 4 layers, each layer consisting of 2^(n-1) nodes. It has 15 nodes in total, 8 of which are leaves. The tree generated by this method will always be balanced and full. As an illustration, a tree of depth 4 looks like this. ~ represents forwarding links to be explained later. 
```
         1               
        / \       
       /   \      
      /     \     
     /       \    
     2        3       
    / \      / \   
   /   \    /   \  
  4    5~~~~6    7   
 / \  / \  / \  / \ 
8~~~9~A~~B~C~~D~E~~F 
```

A tree consists of the following fields:
```python
self.depth = depth
self.__tree = [None]        # data structure holding the tree
self.nodes = tree[1:]       # all nodes except the placehold at [0]
self.forwarding_links = []
```

The constructor takes in one parameter ```depth```. It populates the tree, represented as a list, with 2^(n-1) nodes. It then constructs the tree off the list with the following rules:

- Index [0] is merely a placeholder 
- Root is stored at index[1] rather than [0]
- For node at index [i], its left child is at [2i], right child is at [2i+1].

### Forwarding links
Since MAERI targets accelearting particularly CNNs, forwarding links are required between nodes to pass gradients and other data. In MAERI, forwarding links exsists in between **alternating adder nodes** within each adder layer, excluding the outside edge of tree, as well as between adjacent multiplication (leaf) nodes. This slide will help explain. [link](https://bracketmaster.github.io/MAERI-RTL/main_presentation/_static/maeri_on_fpga_from_concept_to_conception.html#/5)

We can view forwarding links in the tree by simply accessing ```self.forwarding_links```. It is a list of tuples, which stores two ends of a link. 

In the constructor, we create the forwarding links using this chunk of code.

```python
self.forwarding_links = []
    for (node1, node2) in zip(tree[3::2], tree[4::2]):
        # exclude edge nodes
        if (log(node1.id + 1, 2) % 1) == 0:
            continue
        if (log(node2.id, 2) % 1) == 0:
            continue
        self.forwarding_links.append((node1, node2))
## THIS IS BECAUSE
# - Nodes on the left edge has index 2^n
# - Nodes on the right edge has index 2^(n-1)
# - Leaves nodes are taken case of by 
```

You might wonder what does ```zip()``` do. It takes in two lists with the same length (otherwise the longer one is concatnated), and pairs items at same indices as a tuple. For example:

```python
a = [1, 2, 3, 4]
b = [5, 6, 7, 8]
for (val1, val2) in zip(a, b):
    print(val1, val2)

### OUTPUTS 
1 5
2 6
3 7
4 8
```
